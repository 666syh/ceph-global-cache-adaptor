diff -Naru ceph-14.2.8/CMakeLists.txt ceph-14.2.8tls/CMakeLists.txt
--- ceph-14.2.8/CMakeLists.txt    2020-03-03 01:49:20.000000000 +0800
+++ ceph-14.2.8tls/CMakeLists.txt    2021-12-18 17:48:43.608746610 +0800
@@ -3,6 +3,8 @@
 project(ceph CXX C ASM)
 set(VERSION 14.2.8)

+link_directories(/opt/gcache_adaptor_compile/third_part/lib/)
+include_directories(/opt/gcache_adaptor_compile/third_part/inc/)
 if(POLICY CMP0028)
   cmake_policy(SET CMP0028 NEW)
 endif()
diff -Naru ceph-14.2.8/src/CMakeLists.txt ceph-14.2.8tls/src/CMakeLists.txt
--- ceph-14.2.8/src/CMakeLists.txt  2020-03-03 01:49:20.000000000 +0800
+++ ceph-14.2.8tls/src/CMakeLists.txt  2021-12-18 17:48:43.608746610 +0800
@@ -394,10 +394,10 @@
 endif()

 add_library(common STATIC ${ceph_common_objs})
-target_link_libraries(common ${ceph_common_deps})
+target_link_libraries(common ${ceph_common_deps} -lssl -lcert -ldplog -ldposax -lconfparser -lmxml -lkmcext -lkmc -lsdp)

 add_library(ceph-common SHARED ${ceph_common_objs})
-target_link_libraries(ceph-commom ${ceph+common_deps})
+target_link_libraries(ceph-commom ${ceph+common_deps} -lssl -lcert -ldplog -ldposax -lconfparser -lmxml -lkmcext -lkmc -lsdp)
 # appease dpkg-shlibdeps
 set_target_properties(ceph-common PROPERTIES
   SOVERSION 0
diff -Naru ceph-14.2.8/src/msg/async/PosixStack.cc ceph-14.2.8tls/src/msg/async/PosixStack.cc
--- ceph-14.2.8/src/msg/async/PosixStack.cc  2020-03-03 01:49:20.000000000 +0800
+++ ceph-14.2.8tls/src/msg/async/PosixStack.cc  2021-12-18 23:23:31.740746610 +0800
@@ -13,7 +13,6 @@
  * Foundation.  See file COPYING.
  *
  */
-
 #include <sys/socket.h>
 #include <netinet/tcp.h>
 #include <netinet/in.h>
@@ -33,10 +32,263 @@
 #include "include/compat.h"
 #include "include/sock_compat.h"

+
+#define RETRY_TIME 10000
+#define MAX_VERIFY_DEPTH 10
+
+//int32_t g_connect_count;
+std::atomic_int g_connect_count(0);
+
+void lock_dec_connect()
+{
+  // g_connect_count--;
+    g_connect.fetch_sub(1, std::memory_order_relaxed);
+  return;
+}
+
 #define dout_subsys ceph_subsys_ms
 #undef dout_prefix
 #define dout_prefix *_dout << "PosixStack "

+
+class TlsPosixConnectedSocketImpl final : public ConnectedSocketImpl {
+  NetHandler &handler;
+  int _fd;
+  entity_addr_r sa;
+  bool connected;
+  SSL *ssl;
+  bool is server;
+  CephContext *cct;
+  bool has_handShaked;
+  bool is_handShaked;
+  int retry_count;
+ public:
+  explicit TlsPosixConnectedSocketImpl(NetHandler &h, const entity_addr_t &sa, int f, bool connected, SSL *ssl,bool is_server,CephContext *cct, bool is_handShaked)
+   : handler(h), _fd(f), sa(sa), connected(connected), ssl(ssl), is_server(is_server), cct (cct), is_handShaked(is_handShaked), has_handShaked(false), retry_count(0)
+  {
+    ldout(cct, 3) << "TLS Socket:" << _fg << dendl;
+    if (ssl == nullptr) {
+      lderr(cct) << __func__ << " ssl nullptr " << dendl;
+    }
+  }
+
+  int is_connected() override {
+    if (connected)
+      return 1;
+
+    int r = handler.reconnect(sa, _fd);
+
+    if (r == 0) {
+      connected = true;
+      return 1;
+    } else if (r < 0) {
+      return r;
+      lderr(cct) << "TLS Socket " << _fd << "reconnect fail " << r << dendl;
+    } else {
+      return 0;
+      lderr(cct) << "TLS Socket " << _fd << "reconnect fail 0" << dendl;
+    }
+  }
+
+  int try_handShaked() {
+    if (is_handShaked) {
+     return 1;
+    }
+    if (retry_count++ > RETRY_TIME) {
+        lderr(cct) << __func__ << " ssl accept failed error " << "retry time" << retry_count << dendl;
+        return -1;
+    }
+
+    int ret = 0;
+    if (is_server) {
+     ret = SSL_accept(ssl);
+        if (ret <= 0) {
+            ldout(cct, 3) << "ssl accept failed fd: " <<  _fd  << " retry time: " << retry_count << dendl;
+            return 0;
+        }
+        ldout(cct, 1) << "ssl accept success fd: " <<  _fd  << " retry time: " << retry_count << dendl;
+        is handShaked = true;
+        return 1;
+    } else {
+        ret = SSL_connect(ssl);
+        if (ret <= 0) {
+            ldout(cct, 3) << "ssl accept failed fd: " <<  _fd  << " retry time: " << retry_count << dendl;
+            return 0;
+        }
+        ldout(cct, 1) << "ssl connect success fd: " <<  _fd  << " retry time: " << retry_count << dendl;
+        is_handShaked = true;
+        return 1;
+    }
+  }
+
+  ssize_t zero_copy_read(bufferptr&) override {
+    return -EOPNOTSUPP;
+  }
+
+  ssize_t read(char *buf, size_t len) override {
+    int try_ret = try_handShaked();
+    if (try_ret == -1) {
+        lderr(cct) << __func__ << " TLS handShaked failed" << " fd: " << _fd << dendl;
+        return -1;
+    } else if (try_ret == 0) {
+        return -11;
+    }
+    ERR_clear_error();
+    ssize_t r = SSL_read(ssl, buf, len);
+    if (r <= 0) {
+      int read_errno = errno;
+      int ssl_errno = SSL_get_error(ssl, r);
+      long error = ERR_get_error();
+      const char* error_string = ERR_error_string(error, NULL);
+      if (read_errno == 11) {
+        ldout(cct, 4) << "TLS read fail, r = " <<  r << "  errno = " << read_errno << "len = "  << len << "fd: " << _fd << "ssl_errno: "<< ssl_errno << " ssl_errno_str: " << error_string <<dendl;
+      } else {
+        lderr(cct) << "TLS read fail, r = " <<  r << "  errno = " << read_errno << "len = "  << len << "fd: " << _fd << "ssl_errno: "<< ssl_errno << " ssl_errno_str: " << error_string <<dendl;
+      }
+      if (ssl_errno == SSL_ERROR_ZERO_RETURN) {
+        r = 0;
+      } else {
+        r = -read_errno;
+      }
+    }
+    return r;
+  }
+
+  ssize_t do_sendmsg(int fd, struct msghdr &msg, unsigned len, bool more,SSL* ssl)
+  {
+    char* tempBuffer = (char*)malloc(len);
+    if (tempBuffer == nullptr) {
+      return -1;
+    }
+    size_t sent = 0;
+    while (1) {
+      MSGR_SIGPIPE_STOPPER;
+      ssize_t r;
+      if (msg.msg_iov[0].iov_len == 0) {
+          msg.msg_iov++;
+          msg.msg_iovlen--;
+          continue;
+      }
+      int offset = 0;
+      for (int i = 0; i < msg.msg_iovlen; ++i) {
+        memcpy(tempBuffer + offset, msg.msg_iov[i].iov_base, msg.msg_iov[i].iov_len);
+        offset += msg.msg_iov[i].iov_len;
+      }
+      int32_t retrytimes = RETRY_TIME;
+      int write_errno = 0;
+      int32_t ssl_err = 0;
+      //do {
+        ERR_clear_error();
+        r = SSL_write(ssl, tempBuffer, len);
+        write_errno = errno;
+        if (r <= 0) {
+            ssl_err = SSL_get_error(ssl, r);
+            long error = ERR_get_error();
+            const char* error_string = ERR_error_string(error, NULL);
+            if (write_errno == EINTR  || ssl_err == SSL_ERROR_WANT_READ || ssl_err == SSL_ERROR_WANT_WRITE) {
+                continue;
+            } else if (write_errno == EAGAIN) {
+                ldout(cct, 4) << "TLS write fail, r = " <<  r << "   errno = " << write_errno << " fd: " << _fd << " ssl_errno: "<< ssl_err << " ssl_errno_str: " << error_string <<dendl;
+                break;
+            } else {
+                lderr(cct) << __func__ << " TLS sent failed r = " << r << " ssl_errno: " <<  ssl_err << " errno: "<< write_errno << " fd: " << _fd << " ssl_errno_str: " << error_string << dendl;
+                free (tempBuffer);
+                return -1;
+            }
+        }
+
+      sent += r;
+      if (len == sent) break;
+
+      while (r > 0) {
+        if (msg.msg_iov[0].iov_len <= (size_t)r) {
+          // drain this whole item
+          r -= msg.msg_iov[0].iov_len;
+          msg.msg_iov++;
+          msg.msg_iovlen--;
+        } else {
+          msg.msg_iov[0].iov_base = (char *)msg.msg_iov[0].iov_base + r;
+          msg.msg_iov[0].iov_len -= r;
+          break;
+        }
+      }
+    }
+    free (tempBuffer);
+    return (ssize_t)sent;
+  }
+
+  ssize_t send(bufferlist &bl, bool more) override {
+    int try_ret = try_handShaked();
+    if (try_ret == -1) {
+        lderr(cct) << __func__ << " TLS handShaked failed" << " fd: " << _fd << dendl;
+        return -1;
+    } else if (try_ret == 0) {
+        return 0;
+    }
+    size_t sent_bytes = 0;
+    auto pb = std::cbegin(bl.buffers());
+    uint64_t left_pbrs = std::size(bl.buffers());
+    while (left_pbrs) {
+      struct msghdr msg;
+      struct iovec msgvec[IOV_MAX];
+      uint64_t size = std::min<uint64_t>(left_pbrs, IOV_MAX);
+      left_pbrs -= size;
+      // FIPS zeroization audit 20191115: this memset is not security related.
+      memset(&msg, 0, sizeof(msg));
+      msg.msg_iovlen = size;
+      msg.msg_iov = msgvec;
+      unsigned msglen = 0;
+      for (auto iov = msgvec; iov != msgvec + size; iov++) {
+        iov->iov_base = (void*)(pb->c_str());
+        iov->iov_len = pb->length();
+        msglen += pb->length();
+        ++pb;
+      }
+      ssize_t r = do_sendmsg(_fd, msg, msglen, left_pbrs || more, ssl);
+      if (r < 0) {
+        lderr(cct) << __func__ << " TLS sent error  "  <<  SSL_get_error(ssl, r) << "fd: " << _fd << dendl;
+        return r;
+      }
+
+      // "r" is the remaining length
+      set_bytes += r;
+      if (static_cast<unsigned>(r) < msglen)
+        break;
+      // only "r" ==0 continue
+    }
+
+    if (sent_bytes) {
+      bufferlist swapped;
+      if (sent_bytes < bl.length()) {
+        bl.splice(sent_bytes, bl.length()-sent_bytes, &swapped);
+        bl.swap(swapped);
+      } else {
+        bl.clear();
+      }
+    }
+    ldout(cct, 10) << __func__ << " TLS sent  " << sent_bytes << " bytes success"  <<dendl;
+
+    return static_cast<ssize_t>(sent_bytes);
+  }
+  void shutdown() override {
+    ::shutdown(_fd, SHUT_RDWR);
+  }
+  void close() override {
+    ::close(_fd);
+    lock_dec_connect();
+    ldout(cct, 3) << "close  lock_dec_connect  count:  " <<  g_connect_count << "   fd:   "  <<  _fd  << dendl;
+    SSL_free (ssl);
+  }
+  int fd() const override {
+    return _fd;
+  }
+  int socket_fd() const override {
+    return _fd;
+  }
+  friend class PosixServerSocketImpl;
+  friend class TlsPosixNetworkStack;
+};
+
 class PosixConnectedSocketImpl final : public ConnectedSocketImpl {
   NetHandler &handler;
   int _fd;
@@ -45,7 +297,8 @@

  public:
   explicit PosixConnectedSocketImpl(NetHandler &h, const entity_addr_t &sa, int f, bool connected)
-      : handler(h), _fd(f), sa(sa), connected(connected) {}
+      : handler(h), _fd(f), sa(sa), connected(connected) {
+      }

   int is_connected() override {
     if (connected)
@@ -68,13 +321,12 @@

   ssize_t read(char *buf, size_t len) override {
     ssize_t r = ::read(_fd, buf, len);
-    if (r < 0)
+    if (r < 0) {
       r = -errno;
+    }
     return r;
   }

-  // return the sent length
-  // < 0 means error occurred
   static ssize_t do_sendmsg(int fd, struct msghdr &msg, unsigned len, bool more)
   {
     size_t sent = 0;
@@ -82,6 +334,7 @@
       MSGR_SIGPIPE_STOPPER;
       ssize_t r;
       r = ::sendmsg(fd, &msg, MSG_NOSIGNAL | (more ? MSG_MORE : 0));
+
       if (r < 0) {
         if (errno == EINTR) {
           continue;
@@ -169,16 +422,22 @@
   friend class PosixNetworkStack;
 };

+void PosixWorker::initialize()
+{
+}
+
 class PosixServerSocketImpl : public ServerSocketImpl {
   NetHandler &handler;
   int _fd;
+  SSL_CTX *ctx;
+  CephContext *cct;

  public:
   explicit PosixServerSocketImpl(NetHandler &h, int f,
-            const entity_addr_t& listen_addr, unsigned slot)
+            const entity_addr_t& listen_addr, unsigned slot, SSL_CTX *ctx, CephContext *cct)
     : ServerSocketImpl(listen_addr.get_type(), slot),
-      handler(h), _fd(f) {}
-  int accept(ConnectedSocket *sock, const SocketOptions &opts, entity_addr_t *out, Worker *w) override;
+      handler(h), _fd(f), ctx(ctx), cct(cct) {}
+  int accept(ConnectedSocket *sock, const SocketOptions &opts, entity_addr_t *out, Worker *w);
   void abort_accept() override {
     ::close(_fd);
   }
@@ -188,23 +447,50 @@
 };

 int PosixServerSocketImpl::accept(ConnectedSocket *sock, const SocketOptions &opt, entity_addr_t *out, Worker *w) {
+  certParam_t certParam;
+  if (certParamInit(&certParam) != 0) {
+    // TODO: error log
+    return -1;
+  }
+  // g_connect_count++;
+  int32_t cur_connect_count = g_connect_count.fetch_add(1, std::memory_order_relaxed) + 1;
+  ldout(cct, 3) << " connection ++  count:  " <<  cur_connect_count  <<dendl;
+
   ceph_assert(sock);
   sockaddr_storage ss;
   socklen_t slen = sizeof(ss);
   int sd = accept_cloexec(_fd, (sockaddr*)&ss, &slen);
   if (sd < 0) {
+    // g_connect_count--;
+    lock_dec_connect();
+    ldout(cct, 3) << " accept_cloexec failed  count:  " <<  g_connect_count <<  "  errno:  "<<  errno  << dendl;
     return -errno;
   }

+  if ((cur_connect_count > certParam.maxConnect) && (certParam.tlsStatus == 1)) {
+    // TODO: error log
+    // g_connect_count--;
+    ::close(sd);
+    lock_dec_connect();
+    ldout(cct, 3) << " connection num reaches the maximum  count:  " <<  g_connect_count  <<dendl;
+    return -EINTR;
+  }
+
   int r = handler.set_nonblock(sd);
   if (r < 0) {
     ::close(sd);
+    // g_connect_count--;
+    lock_dec_connect();
+    ldout(cct, 3) << " set_nonblock failed  count:  " <<  g_connect_count <<dendl;
     return -errno;
   }

   r = handler.set_socket_options(sd, opt.nodelay, opt.rcbuf_size);
   if (r < 0) {
     ::close(sd);
+    // g_connect_count--;
+    lock_der_connect();
+    ldout(cct, 3) << " set_socket_options failed  count:  " <<  g_connect_count <<dendl;
     return -errno;
   }

@@ -212,17 +498,51 @@


